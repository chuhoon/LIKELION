<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
  </head>
  <body>
    <script>
      class Sausage {
        constructor(el1, el2) {
          this.inside1 = el1;
          this.inside2 = el2;
        }

        taste() {
          console.log(
            `${this.inside1}맛 소세지를 먹었더니 ${this.inside2}이 난다.`
          );
        }
      }

      class FiresSausage extends Sausage {
        taste() {
          console.log(
            `${this.inside1}맛 소세지를 먹었더니 ${this.inside2}이 난다. 불맛도 난다.`
          );
        }
      }

      const solution1 = new Sausage('파맛소세지', '파맛');
      console.log(solution1.taste());

      const solution2 = new Sausage('불고기소세지', '불고기맛');
      console.log(solution2.taste());

      const solution3 = new FiresSausage('불맛소세지', '불맛');
      console.log(solution3.taste());

      // --------------------------------
      class Robot {
        // 클래스의 생성자 함수입니다. 하나의 클래스는 하나의 생성자만 정의할 수 있습니다.
        // 그리고 생성자 함수는 new 키워드가 호출될때 자동으로 실행됩니다.
        constructor(name) {
          this.name = name;
        }

        // 메소드를 정의합니다. 메소드는 클래스가 생성한 인스턴스를 통해 사용할 수 있습니다.
        sayYourName() {
          console.log(`삐리비리. 제 이름은 ${this.name}입니다. 주인님.`);
        }
      }

      class BabyRobot extends Robot {
        constructor(name) {
          super(name);
          this.ownName = '아이크';
        }

        sayBabyName() {
          // 또한 상속을 받게되면 부모 클래스의 메소드를 사용할 수 있게 됩니다. 때문에 this로 접근 할 수 있습니다.
          this.sayYourName();
          console.log(`Suceeding you, Father! ${this.ownName}`);
        }
      }

      const solution4 = new Robot('경훈');
      console.log(solution4.sayYourName());

      const solution5 = new BabyRobot('추경훈');
      console.log(solution5.sayYourName());
      console.log(solution5.sayBabyName());
    </script>
  </body>
</html>
